<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Fetch & Display JSON</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
:root { color-scheme: light dark; font-family: system-ui,-apple-system,Segoe UI,Roboto,sans-serif; }
body { margin: 1.25rem; max-width: 900px; }
h1 { font-size: 1.25rem; margin-bottom: .75rem; }
form, .result, .error, pre { margin-top: 1rem; }
label { display: block; margin: .5rem 0 .25rem; font-weight: 600; }
input[type=text], textarea { width: 100%; padding: .5rem; font-family: inherit; }
button { padding: .6rem 1rem; font-weight: 600; cursor: pointer; }
.code-block { background: #1113; padding: .75rem; border-radius: .5rem; overflow:auto; }
.status { font-size: .8rem; opacity: .7; }
.loading { animation: pulse 1s linear infinite alternate; }
@keyframes pulse { from { opacity:.4 } to { opacity:1 } }
.small { font-size:.75rem; }
.notice { font-size:.85rem; opacity:.8; }
</style>
</head>
<body>
<h1>Fetch & Display JSON</h1>
<p>Reads ?origin=… and optionally falls back through ?proxy=… if the origin blocks CORS. Everything runs client-side.</p>

<form id="fetchForm">
  <label for="origin">Origin URL (?origin=...)</label>
  <input type="text" id="origin" name="origin" placeholder="https://poe.com/GiveQuinnMoney">

  <label for="key">JSON Key to display (optional, ?key=...)</label>
  <input type="text" id="key" name="key" placeholder="topLevelProperty">

  <details>
    <summary>Advanced (method, body, headers, proxy, selector)</summary>
    <label for="method">HTTP Method (?method=GET/POST)</label>
    <input type="text" id="method" name="method" placeholder="GET">

    <label for="body">Body (?body=...)</label>
    <textarea id="body" name="body" rows="3" placeholder='{"example":"value"}'></textarea>

    <label for="headers">Headers (?headers=Header1:Value1,Header2:Value2)</label>
    <input type="text" id="headers" name="headers" placeholder="Content-Type:application/json,X-Api-Key:123">

    <label for="proxy">Proxy base (?proxy=http://host:8000/proxy)</label>
    <input type="text" id="proxy" name="proxy" placeholder="http://127.0.0.1:8000/proxy">

    <label for="selector">HTML selector (optional, ?selector=...)</label>
    <input type="text" id="selector" name="selector" placeholder="#someId or meta[name=foo]">

    <label for="attr">HTML attribute to show (optional, ?attr=...)</label>
    <input type="text" id="attr" name="attr" placeholder="content">
  </details>

  <button type="submit">Fetch</button>
</form>

<div id="status" class="status"></div>
<div id="output"></div>
<p class="notice">Note: Direct cross-origin fetches require the target to send appropriate CORS headers. If blocked, this page will try your provided proxy.</p>

<script>
(function init() {
  const params = new URLSearchParams(location.search);
  const $origin = byId('origin'), $key = byId('key'), $method = byId('method');
  const $body = byId('body'), $headers = byId('headers'), $proxy = byId('proxy');
  const $selector = byId('selector'), $attr = byId('attr');

  for (const [k, el] of Object.entries({origin:$origin,key:$key,method:$method,body:$body,headers:$headers,proxy:$proxy,selector:$selector,attr:$attr})) {
    if (params.has(k)) el.value = params.get(k);
  }

  if ($origin.value) fetchData();
  byId('fetchForm').addEventListener('submit', e => {
    e.preventDefault(); fetchData();
  });

  async function fetchData() {
    clearOutput();
    const origin = $origin.value.trim();
    if (!origin) return showError("No origin URL provided.");

    const method = ($method.value.trim() || 'GET').toUpperCase();
    let body = $body.value.trim();
    const headers = parseHeaders($headers.value.trim());
    const proxyBase = $proxy.value.trim();
    const selector = $selector.value.trim();
    const attr = $attr.value.trim();

    setStatus('Fetching…', true);

    const options = buildInit(method, body, headers);
    let resp, via = 'direct';
    try {
      resp = await fetch(origin, options);
      // If opaque (no-cors), you cannot read it; treat as CORS failure.
      if (resp.type === 'opaque') throw new Error('Opaque response (likely no-cors/CORS-blocked)');
      if (!resp.ok) throw new Error('HTTP ' + resp.status);
    } catch (e) {
      if (proxyBase) {
        try {
          const proxied = makeProxyUrl(proxyBase, origin);
          resp = await fetch(proxied, options);
          via = 'proxy';
        } catch (e2) {
          setStatus('', false);
          return showError('Fetch failed (direct and via proxy): ' + e2.message);
        }
      } else {
        setStatus('', false);
        return showError('Fetch failed (likely CORS). Add ?proxy=http://host:port/proxy to auto-fallback.');
      }
    }

    try {
      setStatus((via === 'proxy' ? 'HTTP ' + resp.status + ' (via proxy)' : 'HTTP ' + resp.status), false);
      const ctype = (resp.headers.get('content-type') || '').toLowerCase();

      let data = null, raw = null, htmlDoc = null;

      if (ctype.includes('application/json') || ctype.includes('+json')) {
        data = await resp.json();
        raw = JSON.stringify(data, null, 2);
      } else {
        const text = await resp.text();
        raw = text;
        // Try structured extraction from HTML
        htmlDoc = toHTML(text);
        data = tryExtractJSONFromHTML(text, htmlDoc) || tryParseFirstJSONObject(text);
      }

      displayResult({ data, raw, selector, attr, key: $key.value.trim(), htmlDoc });
    } catch (err) {
      showError('Error reading response: ' + err.message);
    }
  }

  function buildInit(method, body, headers) {
    const init = { method, headers };
    if (method !== 'GET' && method !== 'HEAD' && body) {
      if (looksLikeJSON(body)) {
        headers['Content-Type'] = headers['Content-Type'] || 'application/json';
        init.body = body;
      } else {
        headers['Content-Type'] = headers['Content-Type'] || 'application/x-www-form-urlencoded';
        init.body = body;
      }
    }
    return init;
  }

  function makeProxyUrl(proxyBase, target) {
    const hasQ = proxyBase.includes('?');
    const sep = hasQ ? '&' : '?';
    return proxyBase + sep + 'url=' + encodeURIComponent(target);
  }

  function displayResult({ data, raw, selector, attr, key, htmlDoc }) {
    const out = byId('output');
    let html = '';

    // Extract from HTML with selector if requested
    if (htmlDoc && selector) {
      const node = htmlDoc.querySelector(selector);
      if (node) {
        const value = attr ? node.getAttribute(attr) : node.textContent;
        html += `<p><strong>Selector:</strong> ${escapeHtml(selector)}${attr ? ' @'+escapeHtml(attr) : ''}</p>`;
        html += `<pre class="code-block">${escapeHtml((value ?? '').toString())}</pre>`;
      } else {
        html += `<p><strong>Selector:</strong> ${escapeHtml(selector)} not found.</p>`;
      }
    }

    // Show JSON (full or by key)
    if (data) {
      if (key) {
        const val = resolveKey(data, key);
        if (val === undefined) {
          html += `<p><strong>Key:</strong> "${escapeHtml(key)}" not found in JSON.</p>`;
        } else {
          html += `<p><strong>Value for "${escapeHtml(key)}":</strong></p><pre class="code-block">${escapeHtml(JSON.stringify(val, null, 2))}</pre>`;
        }
      } else {
        html += `<p><strong>Parsed JSON:</strong></p><pre class="code-block">${escapeHtml(JSON.stringify(data, null, 2))}</pre>`;
      }
    }

    // Always show raw
    html += `<details open><summary>Raw Response</summary><pre class="code-block">${escapeHtml(raw || 'No raw data')}</pre></details>`;
    out.innerHTML = html;
  }

  function tryExtractJSONFromHTML(text, doc) {
    // Next.js inline assignment
    const rxNextAssign = /window\.__NEXT_DATA__\s*=\s*({[\s\S]*?});?\s*<\/script>/i;
    const m = text.match(rxNextAssign);
    if (m) {
      try { return JSON.parse(m[1]); } catch {}
    }

    // Next.js script tag
    if (doc) {
      const nextTag = doc.querySelector('script#__NEXT_DATA__');
      if (nextTag && nextTag.textContent) {
        try { return JSON.parse(nextTag.textContent); } catch {}
      }
      // Any JSON-ish script tags
      const jsonScripts = doc.querySelectorAll('script[type*="json"]');
      for (const s of jsonScripts) {
        if (s.textContent) {
          try { return JSON.parse(s.textContent); } catch {}
        }
      }
      // LD+JSON specifically
      const ld = doc.querySelectorAll('script[type="application/ld+json"]');
      for (const s of ld) {
        if (s.textContent) {
          try { return JSON.parse(s.textContent); } catch {}
        }
      }
    }
    return null;
  }

  function tryParseFirstJSONObject(text) {
    const match = text.match(/\{[\s\S]*\}/);
    if (!match) return null;
    try { return JSON.parse(match[0]); } catch { return null; }
  }

  function toHTML(text) {
    try {
      const p = new DOMParser();
      return p.parseFromString(text, 'text/html');
    } catch { return null; }
  }

  function resolveKey(obj, keyPath) {
    return keyPath.split('.').reduce((acc, k) => acc != null ? acc[k] : undefined, obj);
  }

  function parseHeaders(str) {
    const hdrs = {};
    if (!str) return hdrs;
    str.split(',').forEach(pair => {
      const [k, ...rest] = pair.split(':');
      if (!k || !rest.length) return;
      hdrs[k.trim()] = rest.join(':').trim();
    });
    return hdrs;
  }

  function looksLikeJSON(s) {
    return (s.startsWith('{') && s.endsWith('}')) || (s.startsWith('[') && s.endsWith(']'));
  }

  function escapeHtml(s) {
    return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }
  function setStatus(msg, loading) {
    const el = byId('status');
    el.textContent = msg || '';
    el.classList.toggle('loading', !!loading);
  }
  function clearOutput() { byId('output').innerHTML = ''; setStatus('', false); }
  function showError(msg) {
    byId('output').innerHTML = `<div class="error" style="color:#c00;font-weight:600;">${escapeHtml(msg)}</div>`;
  }
  function byId(id) { return document.getElementById(id); }
})();
</script>
</body>
</html>
